//====================================================================================================================================================
// Copyright 2025 Lake Orion Robotics FIRST Team 302
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
// OR OTHER DEALINGS IN THE SOFTWARE.
//====================================================================================================================================================
// This file was automatically generated by the Team 302 code generator version 20.25.00.08
// Generated on Monday, November 17, 2025 7:36:52 PM

#include <string>

// FRC Includes
#include <networktables/NetworkTableInstance.h>
#include <frc/Timer.h>

#include "Delivery.h"
#include "utils/logging/debug/Logger.h"
#include "utils/PeriodicLooper.h"
#include "state/RobotState.h"
#include "utils/DragonPower.h"

#include "rev/SparkMax.h"
#include "mechanisms/Delivery/OffState.h"
#include "mechanisms/Delivery/ScoreState.h"
#include "mechanisms/Delivery/ReverseState.h"

using std::string;
using namespace DeliveryStates;

void Delivery::CreateAndRegisterStates()
{
	OffState *OffStateInst = new OffState(string("Off"), 0, this, m_activeRobotId);
	AddToStateVector(OffStateInst);

	ScoreState *ScoreStateInst = new ScoreState(string("Score"), 1, this, m_activeRobotId);
	AddToStateVector(ScoreStateInst);

	ReverseState *ReverseStateInst = new ReverseState(string("Reverse"), 2, this, m_activeRobotId);
	AddToStateVector(ReverseStateInst);

	OffStateInst->RegisterTransitionState(ScoreStateInst);
	OffStateInst->RegisterTransitionState(ReverseStateInst);
	ScoreStateInst->RegisterTransitionState(OffStateInst);
	ScoreStateInst->RegisterTransitionState(ReverseStateInst);
	ReverseStateInst->RegisterTransitionState(OffStateInst);
	ReverseStateInst->RegisterTransitionState(ScoreStateInst);
}

Delivery::Delivery(RobotIdentifier activeRobotId) : BaseMech(MechanismTypes::MECHANISM_TYPE::DELIVERY, std::string("Delivery")),
													m_activeRobotId(activeRobotId),
													m_stateMap()
{
	PeriodicLooper::GetInstance()->RegisterAll(this);
	// InitializeLogging();
}

/* void Delivery::InitializeLogging()
 {
	wpi::log::DataLog &log = frc::DataLogManager::GetLog();

	 m_DeliveryTotalEnergyLogEntry = wpi::log::DoubleLogEntry(log, "mechanisms/Delivery/TotalEnergy");
m_DeliveryTotalEnergyLogEntry.Append(0.0);
m_DeliveryTotalWattHoursLogEntry = wpi::log::DoubleLogEntry(log, "mechanisms/Delivery/TotalWattHours");
m_DeliveryTotalWattHoursLogEntry.Append(0.0);
m_DeliveryLogEntry = wpi::log::DoubleLogEntry(log, "mechanisms/Delivery/DeliveryPosition");
m_DeliveryLogEntry.Append(0.0);
m_DeliveryTargetLogEntry = wpi::log::DoubleLogEntry(log, "mechanisms/Delivery/DeliveryTarget");
m_DeliveryTargetLogEntry.Append(0.0);
m_DeliveryPowerLogEntry = wpi::log::DoubleLogEntry(log, "mechanisms/Delivery/DeliveryPower");
m_DeliveryPowerLogEntry.Append(0.0);
m_DeliveryEnergyLogEntry = wpi::log::DoubleLogEntry(log, "mechanisms/Delivery/DeliveryEnergy");
m_DeliveryEnergyLogEntry.Append(0.0);
m_DeliveryStateLogEntry = wpi::log::IntegerLogEntry(log, "mechanisms/Delivery/State");
m_DeliveryStateLogEntry.Append(0);
 }*/

std::map<std::string, Delivery::STATE_NAMES>
	Delivery::stringToSTATE_NAMESEnumMap{
		{"STATE_OFF", Delivery::STATE_NAMES::STATE_OFF},
		{"STATE_SCORE", Delivery::STATE_NAMES::STATE_SCORE},
		{"STATE_REVERSE", Delivery::STATE_NAMES::STATE_REVERSE},
	};

void Delivery::CreateKitBot2025()
{
	m_ntName = "Delivery";
	m_Delivery = new rev::spark::SparkMax(6, rev::spark::SparkLowLevel::MotorType::kBrushed);

	m_PercentOut = new ControlData(
		ControlModes::CONTROL_TYPE::PERCENT_OUTPUT,		  // ControlModes::CONTROL_TYPE mode
		ControlModes::CONTROL_RUN_LOCS::MOTOR_CONTROLLER, // ControlModes::CONTROL_RUN_LOCS server
		"m_PercentOut",									  // std::string indentifier
		0,												  // double proportional
		0,												  // double integral
		0,												  // double derivative
		0,												  // double feedforward
		0,												  // double velocityGain
		0,												  // double accelartionGain
		0,												  // double staticFrictionGain,

		ControlData::FEEDFORWARD_TYPE::VOLTAGE,					 // FEEDFORWARD_TYPE feedforwadType
		0,														 // double integralZone
		0,														 // double maxAcceleration
		0,														 // double cruiseVelocity
		0,														 // double peakValue
		0,														 // double nominalValue
		false,													 // bool enableFOC
		ControlData::GravityTypeValue::Elevator_Static,			 // Gravity type
		ControlData::StaticFeedforwardSignValue::UseVelocitySign // Static feedforward sign
	);

	ReadConstants("Delivery.xml", 2025);
}

void Delivery::InitializeKitBot2025()
{
	InitializeSparkMaxDeliveryKitBot2025();
}
void Delivery::InitializeSparkMaxDeliveryKitBot2025()
{
	rev::spark::SparkBaseConfig DeliveryConfig;
	DeliveryConfig.Inverted(false);
	DeliveryConfig.SetIdleMode(rev::spark::SparkBaseConfig::IdleMode::kBrake);
	DeliveryConfig.SmartCurrentLimit(50);
	DeliveryConfig.VoltageCompensation(10);
	DeliveryConfig.OpenLoopRampRate(0.25);
	DeliveryConfig.ClosedLoopRampRate(0.25);
	DeliveryConfig.limitSwitch.ForwardLimitSwitchEnabled(false);
	DeliveryConfig.limitSwitch.ReverseLimitSwitchEnabled(false);
	m_Delivery->Configure(DeliveryConfig, rev::spark::SparkBase::ResetMode::kResetSafeParameters, rev::spark::SparkBase::PersistMode::kPersistParameters);
}

void Delivery::SetCurrentState(int state, bool run)
{
	StateMgr::SetCurrentState(state, run);
}

void Delivery::RunCommonTasks()
{
	// This function is called once per loop before the current state Run()
	Cyclic();
}

/// @brief  Set the control constants (e.g. PIDF values).
/// @param [in] ControlData*                                   pid:  the control constants
/// @return void
void Delivery::SetControlConstants(RobotElementNames::MOTOR_CONTROLLER_USAGE identifier, int slot, ControlData pid)
{
}

/// @brief update the output to the mechanism using the current controller and target value(s)
/// @return void
void Delivery::Update()
{
	;
}

bool Delivery::IsAtMinPosition(RobotElementNames::MOTOR_CONTROLLER_USAGE identifier) const
{
	// auto motor = GetMotorMech(identifier);
	// if (motor != nullptr)
	// {
	//     return motor->IsAtMinTravel();
	// }
	return false;
}

bool Delivery::IsAtMaxPosition(RobotElementNames::MOTOR_CONTROLLER_USAGE identifier) const
{
	// auto motor = GetMotorMech(identifier);
	// if (motor != nullptr)
	// {
	//     return motor->IsAtMaxTravel();
	// }
	return false;
}

void Delivery::Cyclic()
{
	Update();
}

ControlData *Delivery::GetControlData(string name)
{
	if (name.compare("PercentOut") == 0)
		return m_PercentOut;

	return nullptr;
}

/* void Delivery::DataLog(uint64_t timestamp)
{
   auto currTime = m_powerTimer.Get();
LogDelivery(timestamp, m_Delivery->GetPosition().GetValueAsDouble());
auto DeliveryPower = DragonPower::CalcPowerEnergy(currTime, m_Delivery->GetSupplyVoltage().GetValueAsDouble(), m_Delivery->GetSupplyCurrent().GetValueAsDouble());
m_power = get<0>(DeliveryPower);
m_energy = get<1>(DeliveryPower);
m_totalEnergy += m_energy;
LogDeliveryPower(timestamp, m_power);
LogDeliveryEnergy(timestamp, m_energy);
LogDeliveryState(timestamp, GetCurrentState());
m_totalWattHours += DragonPower::ConvertEnergyToWattHours(m_totalEnergy);
LogDeliveryTotalEnergy(timestamp, m_totalEnergy);
LogDeliveryTotalWattHours(timestamp, m_totalWattHours);
m_powerTimer.Reset();
m_powerTimer.Start();
 }*/